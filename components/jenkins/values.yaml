controller:
  componentName: "jenkins-controller"
  image:
    registry: "docker.io"
    repository: "jenkins/jenkins"
    tag:
    tagLabel: jdk17
    pullPolicy: "IfNotPresent"
  resources:
    requests:
      memory: "2Gi"
    limits:
      memory: "2Gi"
  # -- Number of executors on the Jenkins controller (0 = no builds run on master)
  numExecutors: 0
  # -- Name of default cloud configuration.
  cloudName: "openshift"
  # -- Additional Java options for Jenkins controller
  javaOpts: >-
    -Dhudson.model.User.allowNonExistentUserToLogin=false
  # Enable OpenShift OAuth
  containerEnv:
    - name: OPENSHIFT_ENABLE_OAUTH
      value: "true"
    - name: OPENSHIFT_PERMISSIONS_POLL_INTERVAL
      value: "300000"

  # # -- Disable use of remember me
  disableRememberMe: true

  # # -- Sets the executor mode of the Jenkins node. Possible values are "NORMAL" or "EXCLUSIVE"
  executorMode: "NORMAL"

  # # -- Append Jenkins labels to the controller
  # customJenkinsLabels: []

  # Groovy init script to dynamically discover Jenkins URL from OpenShift Route
  initScripts:
    discover-url: |
      import jenkins.model.Jenkins
      import jenkins.model.JenkinsLocationConfiguration
      import java.security.cert.X509Certificate
      import javax.net.ssl.SSLContext
      import javax.net.ssl.TrustManager
      import javax.net.ssl.X509TrustManager
      import javax.net.ssl.HttpsURLConnection

      def jenkins = Jenkins.getInstance()

      try {
          // Read namespace from serviceaccount
          def namespace = new File('/var/run/secrets/kubernetes.io/serviceaccount/namespace').text.trim()
          def token = new File('/var/run/secrets/kubernetes.io/serviceaccount/token').text.trim()

          println "Discovering Jenkins URL from Route in namespace: ${namespace}"

          // Create insecure SSL context for internal API calls
          def trustAllCerts = [
              new X509TrustManager() {
                  X509Certificate[] getAcceptedIssuers() { null }
                  void checkClientTrusted(X509Certificate[] certs, String authType) {}
                  void checkServerTrusted(X509Certificate[] certs, String authType) {}
              }
          ] as TrustManager[]

          def sc = SSLContext.getInstance("TLS")
          sc.init(null, trustAllCerts, new java.security.SecureRandom())

          // Query Kubernetes API for Route
          def apiUrl = "https://kubernetes.default.svc/apis/route.openshift.io/v1/namespaces/${namespace}/routes/jenkins"
          def connection = new URL(apiUrl).openConnection() as HttpsURLConnection
          connection.setRequestProperty("Authorization", "Bearer ${token}")
          connection.setSSLSocketFactory(sc.socketFactory)
          connection.setHostnameVerifier({ hostname, session -> true })

          def response = connection.inputStream.text
          def route = new groovy.json.JsonSlurper().parseText(response)
          def hostname = route.spec.host

          if (hostname) {
              def jenkinsUrl = "https://${hostname}"
              println "Discovered Jenkins URL: ${jenkinsUrl}"

              // Set Jenkins location URL
              def locationConfig = JenkinsLocationConfiguration.get()
              locationConfig.setUrl(jenkinsUrl)
              locationConfig.save()
              println "Jenkins location URL configured: ${jenkinsUrl}"

              // Also configure OpenShift OAuth redirect URL
              try {
                  def securityRealm = jenkins.getSecurityRealm()
                  if (securityRealm != null && securityRealm.getClass().getName().contains("OpenShiftOAuth2SecurityRealm")) {
                      // Use reflection to set the redirectURL field
                      def redirectUrlField = securityRealm.getClass().getDeclaredField("redirectURL")
                      redirectUrlField.setAccessible(true)
                      redirectUrlField.set(securityRealm, jenkinsUrl + "/")
                      jenkins.setSecurityRealm(securityRealm)
                      jenkins.save()
                      println "OpenShift OAuth redirect URL configured: ${jenkinsUrl}/"
                  }
              } catch (Exception oauthEx) {
                  println "Note: Could not configure OAuth redirect URL directly: ${oauthEx.message}"
              }

              println "Jenkins URL configuration completed successfully"
          } else {
              println "WARNING: Could not discover Jenkins URL from Route - hostname was null"
          }
      } catch (Exception e) {
          println "ERROR discovering Jenkins URL from Route: ${e.message}"
          e.printStackTrace()
      }

  JCasC:
    defaultConfig: true
    configScripts:
      jenkins-config: |
        jenkins:
          authorizationStrategy:
            globalMatrix:
              permissions:
                - "Overall/Administer:authenticated"
    # -- Jenkins Config as Code security-section
    security:
      apiToken:
        creationOfLegacyTokenEnabled: false
        tokenGenerationOnCreationEnabled: false
        usageStatisticsEnabled: true

  serviceType: ClusterIP
  servicePort: 8080
  # OpenShift 4.18 uses restricted-v2 SCC by default. To allow the init container to write to the
  # persistent volume, we must set the fsGroup. This ensures the volume is group-writable by the
  # Jenkins user (gid 1000), resolving the permission denied error.
  usePodSecurityContext: true
  podSecurityContextOverride:
    fsGroup: 1000
  containerSecurityContext: {}
  installPlugins:
    - gitlab-plugin
    - github
    - bitbucket
    - kubernetes
    - workflow-aggregator
    - git
    - configuration-as-code
    - job-dsl:latest
    - matrix-auth
    - openshift-login
  # Openshift route
  route:
    # -- Enables openshift route
    enabled: true
    # -- Route labels
    labels: {}
    # -- Route annotations
    annotations: {}
    # -- Route path
    path:

persistence:
  enabled: true
  size: "100Gi"
  # If you have a specific storage class, uncomment and set it here
  # storageClass: "your-storage-class"

rbac:
  create: true
  # This is important for OpenShift to manage SCCs correctly.
  useOpenShiftNonRootSCC: true

serviceAccount:
  create: true
  name: "jenkins"
  annotations:
    serviceaccounts.openshift.io/oauth-redirectreference.jenkins: '{"kind":"OAuthRedirectReference","apiVersion":"v1","reference":{"kind":"Route","name":"jenkins"}}'

agent:
  # -- Enable Kubernetes plugin jnlp-agent podTemplate
  enabled: true
  # -- Max number of agents to launch for a whole cluster.
  containerCap: 100
  # -- Max number of agents to launch for this type of agent
  instanceCap: 2147483647
  # -- Disable the default Jenkins Agent configuration (false = supports "agent any")
  disableDefaultAgent: false
  # -- Agent Pod base name
  podName: default
  # -- Configure working directory for default agent
  workingDir: "/home/jenkins/agent"
  # -- Always pull agent container image before build
  alwaysPullImage: true
  # -- Resources allocation for default agent
  resources:
    requests:
      cpu: "100m"
      memory: "256Mi"
    limits:
      cpu: "500m"
      memory: "1024Mi"

